#include "quantum.h"
#include "4x4.h"
#include "config.h"
#include "keys.h"
#include "qmk_midi.h"

/*
const keypos_t PROGMEM hand_swap_config[MATRIX_ROWS][MATRIX_COLS] = {
  {{6, 4}, {5, 4}, {4, 4}, {3, 4}, {2, 4}, {1, 4}, {0, 4}},
  {{6, 5}, {5, 5}, {4, 5}, {3, 5}, {2, 5}, {1, 5}, {0, 5}},
  {{6, 6}, {5, 6}, {4, 6}, {3, 6}, {2, 6}, {1, 6}, {0, 6}},
  {{6, 7}, {5, 7}, {4, 7}, {3, 7}, {2, 7}, {1, 7}, {0, 7}},
  {{6, 0}, {5, 0}, {4, 0}, {3, 0}, {2, 0}, {1, 0}, {0, 0}},
  {{6, 1}, {5, 1}, {4, 1}, {3, 1}, {2, 1}, {1, 1}, {0, 1}},
  {{6, 2}, {5, 2}, {4, 2}, {3, 2}, {2, 2}, {1, 2}, {0, 2}},
  {{6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 3}, {1, 3}, {0, 3}},
};

// Use encoder for mouse scroll and volume depending on layer
bool encoder_update_user(uint8_t index, bool clockwise) {
	if (0 == index)
	{
		if (clockwise) {
		  tap_code(KC_WH_D);
		} else {
		  tap_code(KC_WH_U);
		}
	} else {
		if (clockwise) {
		  tap_code(KC_WH_R);
		} else {
		  tap_code(KC_WH_L);
		}
	}
	
	return true;
}
*/

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LSFT_T(KC_N):
        case LSFT_T(KC_T):
			return TAPPING_TERM-20;

        //case LCTL_T(KC_E):
        //case LCTL_T(KC_S):
        case LALT_T(KC_I):
        case LALT_T(KC_R):
        case LGUI_T(KC_O):
        case LGUI_T(KC_A):
			return TAPPING_TERM+50;

        default:
            return TAPPING_TERM;
    }
}

bool get_tapping_force_hold(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LSFT_T(KC_N):
        case LSFT_T(KC_T):
        case LCTL_T(KC_E):
        case LCTL_T(KC_S):
        case LALT_T(KC_I):
        case LALT_T(KC_R):
        case LGUI_T(KC_O):
        case LGUI_T(KC_A):
            return true;
			
        default:
            return false;
    }
}

enum held_state {
	HS_NONE = 0,
	HS_HELD = 1,
	HS_GOTKEY = 2
};
	
enum held_state held_ctrl = HS_NONE;

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
	switch (keycode) {
		case HOLD_LCTL:
		case HOLD_LSFT:
		case HOLD_LALT:
		case HOLD_LALTTAB:
		case HOLD_LGUI:
			if (record->event.pressed) {
				switch (keycode) {
					case HOLD_LCTL:
						register_code(KC_LCTL);
						break;
					case HOLD_LSFT:
						register_code(KC_LSFT);
						break;
					case HOLD_LALT:
						register_code(KC_LALT);
						break;
					case HOLD_LALTTAB:
						register_code(KC_LALT);
						SEND_STRING(SS_DOWN(X_TAB) SS_DELAY(50) SS_UP(X_TAB));
						break;
					case HOLD_LGUI:
						register_code(KC_LGUI);
						break;
				}
				if (layer_state == 0) {
					held_ctrl = HS_HELD;
				} else {
					// Treat layer release as end of operation for Alt+Tab
					held_ctrl = HS_GOTKEY;
				}
			}
			return false; // Skip all further processing of this key

		default:
			if (record->event.pressed) {
				if (held_ctrl) {
					held_ctrl = HS_GOTKEY;
				}
			}
    }
	
	if (keycode >= LP_CC_START && keycode <= LP_CC_END)
	{
		uint8_t cc = 91 + keycode - LP_CC_START;
		uint8_t velocity;
		if (record->event.pressed)
		{
			velocity = 127;
		}
		else 
		{
			velocity = 0;
		}
		
		midi_send_cc(&midi_device, midi_config.channel, cc, velocity);
	}
		
    return true;
};

void post_process_record_user(uint16_t keycode, keyrecord_t *record) {
	if ((layer_state & ~STATIC_LAYERSET) == 0) {
		if (held_ctrl == HS_GOTKEY) {
			unregister_code(KC_LCTL);
			unregister_code(KC_LSFT);
			unregister_code(KC_LALT);
			unregister_code(KC_LGUI);
			held_ctrl = HS_NONE;
		}
	}	
}

// Bank 4 lower left: C2, MIDI 48
const int CLIP_BLOCK_START = 48;

char indicators[CLIP_BLOCK_X * CLIP_BLOCK_Y];

void midi_noteon_callback(MidiDevice *device, uint8_t byte0, uint8_t byte1, uint8_t byte2)
{
	if (byte1 >= CLIP_BLOCK_START && byte1 < CLIP_BLOCK_START + CLIP_BLOCK_X * CLIP_BLOCK_Y)
	{
		indicators[byte1 - CLIP_BLOCK_START] = byte2;
		dprintf("MIDI indicator %u vel %u. Set %u\n", byte1, byte2, byte1 - CLIP_BLOCK_START);
	}
}

// Not actually sent?
void midi_noteoff_callback(MidiDevice *device, uint8_t byte0, uint8_t byte1, uint8_t byte2)
{
	if (byte1 >= CLIP_BLOCK_START && byte1 < CLIP_BLOCK_START + CLIP_BLOCK_X * CLIP_BLOCK_Y)
	{
		indicators[byte1 - CLIP_BLOCK_START] = 0;
	}
}

void keyboard_post_init_user(void) {
	midi_register_noteon_callback(&midi_device, midi_noteon_callback);
	midi_register_noteoff_callback(&midi_device, midi_noteoff_callback);
	uprint("MIDI initialized\n");
}

const uint8_t ableton_colors[] =
{
	0x0, 0x0, 0x0,
	0x1e, 0x1e, 0x1e,
	0x7f, 0x7f, 0x7f,
	0xff, 0xff, 0xff,
	0xff, 0x4c, 0x4c,
	0xff, 0x0, 0x0,
	0x59, 0x0, 0x0,
	0x19, 0x0, 0x0,
	0xff, 0xbd, 0x6c,
	0xff, 0x54, 0x0,
	0x59, 0x1d, 0x0,
	0x27, 0x1b, 0x0,
	0xff, 0xff, 0x4c,
	0xff, 0xff, 0x0,
	0x59, 0x59, 0x0,
	0x19, 0x19, 0x0,
	0x88, 0xff, 0x4c,
	0x54, 0xff, 0x0,
	0x1d, 0x59, 0x0,
	0x14, 0x2b, 0x0,
	0x4c, 0xff, 0x4c,
	0x0, 0xff, 0x0,
	0x0, 0x59, 0x0,
	0x0, 0x19, 0x0,
	0x4c, 0xff, 0x5e,
	0x0, 0xff, 0x19,
	0x0, 0x59, 0xd,
	0x0, 0x19, 0x2,
	0x4c, 0xff, 0x88,
	0x0, 0xff, 0x55,
	0x0, 0x59, 0x1d,
	0x0, 0x1f, 0x12,
	0x4c, 0xff, 0xb7,
	0x0, 0xff, 0x99,
	0x0, 0x59, 0x35,
	0x0, 0x19, 0x12,
	0x4c, 0xc3, 0xff,
	0x0, 0xa9, 0xff,
	0x0, 0x41, 0x52,
	0x0, 0x10, 0x19,
	0x4c, 0x88, 0xff,
	0x0, 0x55, 0xff,
	0x0, 0x1d, 0x59,
	0x0, 0x8, 0x19,
	0x4c, 0x4c, 0xff,
	0x0, 0x0, 0xff,
	0x0, 0x0, 0x59,
	0x0, 0x0, 0x19,
	0x87, 0x4c, 0xff,
	0x54, 0x0, 0xff,
	0x19, 0x0, 0x64,
	0xf, 0x0, 0x30,
	0xff, 0x4c, 0xff,
	0xff, 0x0, 0xff,
	0x59, 0x0, 0x59,
	0x19, 0x0, 0x19,
	0xff, 0x4c, 0x87,
	0xff, 0x0, 0x54,
	0x59, 0x0, 0x1d,
	0x22, 0x0, 0x13,
	0xff, 0x15, 0x0,
	0x99, 0x35, 0x0,
	0x79, 0x51, 0x0,
	0x43, 0x64, 0x0,
	0x3, 0x39, 0x0,
	0x0, 0x57, 0x35,
	0x0, 0x54, 0x7f,
	0x0, 0x0, 0xff,
	0x0, 0x45, 0x4f,
	0x25, 0x0, 0xcc,
	0x7f, 0x7f, 0x7f,
	0x20, 0x20, 0x20,
	0xff, 0x0, 0x0,
	0xbd, 0xff, 0x2d,
	0xaf, 0xed, 0x6,
	0x64, 0xff, 0x9,
	0x10, 0x8b, 0x0,
	0x0, 0xff, 0x87,
	0x0, 0xa9, 0xff,
	0x0, 0x2a, 0xff,
	0x3f, 0x0, 0xff,
	0x7a, 0x0, 0xff,
	0xb2, 0x1a, 0x7d,
	0x40, 0x21, 0x0,
	0xff, 0x4a, 0x0,
	0x88, 0xe1, 0x6,
	0x72, 0xff, 0x15,
	0x0, 0xff, 0x0,
	0x3b, 0xff, 0x26,
	0x59, 0xff, 0x71,
	0x38, 0xff, 0xcc,
	0x5b, 0x8a, 0xff,
	0x31, 0x51, 0xc6,
	0x87, 0x7f, 0xe9,
	0xd3, 0x1d, 0xff,
	0xff, 0x0, 0x5d,
	0xff, 0x7f, 0x0,
	0xb9, 0xb0, 0x0,
	0x90, 0xff, 0x0,
	0x83, 0x5d, 0x7,
	0x39, 0x2b, 0x0,
	0x14, 0x4c, 0x10,
	0xd, 0x50, 0x38,
	0x15, 0x15, 0x2a,
	0x16, 0x20, 0x5a,
	0x69, 0x3c, 0x1c,
	0xa8, 0x0, 0xa,
	0xde, 0x51, 0x3d,
	0xd8, 0x6a, 0x1c,
	0xff, 0xe1, 0x26,
	0x9e, 0xe1, 0x2f,
	0x67, 0xb5, 0xf,
	0x1e, 0x1e, 0x30,
	0xdc, 0xff, 0x6b,
	0x80, 0xff, 0xbd,
	0x9a, 0x99, 0xff,
	0x8e, 0x66, 0xff,
	0x40, 0x40, 0x40,
	0x75, 0x75, 0x75,
	0xe0, 0xff, 0xff,
	0xa0, 0x0, 0x0,
	0x35, 0x0, 0x0,
	0x1a, 0xd0, 0x0,
	0x7, 0x42, 0x0,
	0xb9, 0xb0, 0x0,
	0x3f, 0x31, 0x0,
	0xb3, 0x5f, 0x0,
	0x4b, 0x15, 0x2
};